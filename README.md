# Getting Started

### Pre-Requires
- JDK 11
- Maven 3.6.0
- Docker ([Install](https://docs.docker.com/engine/install/ubuntu/ "Install") | [Configure](https://docs.docker.com/v17.09/engine/installation/linux/linux-postinstall/ "Configure"))
- docker-compose ([Install](https://docs.docker.com/compose/install/ "Install"))

## Clean Architecture
![Alt text](docs/clean_architecture.png?raw=true "Clean Architecture Cone")

## Packages structure
![Alt text](docs/packages_clean_architecture.png?raw=true "Clean Architecture Cone")

* businessrule -> Use case, i.e. the application's business rules.
    - dto -> Middle classes created to group multiple objects into one.
    - exception -> Package where the custom exceptions is.
    - gateway -> Package where the interface calls the repository to connect external applications, i.e. usecase call the database.
    - message -> message service used by the validator, e.g. read the error message and get a appropriate message to that error.
    - usecase -> Package where all usecase is.
    - validator -> Package with custom validations, e.g. AutoInsuranceValidator is used to validate the input params in the API .

  
* domain -> Domain entities, i.e. related to the domain's business rules.


* external -> Items related to the most external part of the application, i.e. items related to the application it self.
    - configuration -> Items related to the application's configuration in general, i.e. database configuration, cache configuration.


* interfaceadapter -> Items related to the user's access, i.e. Controllers, Gateways, Repositories and Delegate.
    - delegate -> Intended to implement the delegate classes auto generated by the openAPI generator, i.e. it delegates the responsability to the usecase.
    - gateway -> Implements the gateway interface used in the businessrule package.
    - mapper -> Used to suit the domain object comming from the database into the response.
    - repository -> Used to call and get data from the database.
    - util -> Package with utils used in the application.

## Retry

In some scenarios, when we call an external service (for example) we can receive an error. But, this error can be just a momentary error. So, if we call it again in a few seconds, 
we can receive the correct response.

The retry pattern comes to acts in this specific scenario. Before we return an error response for our users,
we wait a few seconds and retry the last call to access the resource. This implementation will make retries a defined number of times, until we get the correct response or we reach the maximum number of retries. If we reach the limit of
number of times, then we return an error for our user saying that we can't reach the resource. The number of times and the wait time can be configured in each scenario.

In the picture below, we can see a scenario where an application tries to call a hosted service. In the first call, the application receives a 500 response. Then it tries again and receives another
500 status. But, when it tries for the third time, it can get the resource that it was trying to reach.
This pattern helps us to reduce the number of errors that are received by our users.

![Alt text](docs/retry_example.png?raw=true "Retry pattern")

But be careful, we need to analyze each scenario. In some cases, if we get an error and keep retrying, we can get more errors and cause more problems in the external service, for example.

To implement this pattern, we use resilience4j. More information can be found at the link: https://resilience4j.readme.io/docs/retry

## Circuit Breaker

In this application, we used the Circuit Breaker Pattern. The idea behind it is to create a mechanism for when an error scenario begins, we stop forcing the external
 service (open the circuit breaker) and then wait a time to call the resource again. The idea is that, when a service is not working properly, if we keep sending requests, 
 we can flood the service and cause more problems. A circuit breaker can have 3 states: closed, open and half-open.
* closed -> The initial state. This state allows the calls to happen as usual and monitor the number of failures occurring within the defined period. If the number of errors reaches the threshold, 
the state will change to an open state;
* open -> Once the circuit breaker moves to an open state, all the requests will be blocked. After a timeout period, the state will change to half-open;
* half-open -> The circuit breaker will allow a limited number of requests. If those requests are successful, the circuit breaker will switch to the closed state again.
If not, it will block the requests again for a defined period of time.

The picture above can illustrate the 3 states and how it works:

![Alt text](docs/circuit_breaker_states.jpg?raw=true "Circuit Breaker states")

To implement this pattern we use resilience4j. More information can be found at the link: https://resilience4j.readme.io/docs/circuitbreaker

## + Configurations
```bash
Make sure you have setup your local Git Hooks:
This will make sure your commit messages follow our Conventional Commits Specification.

> git config core.hooksPath .githooks
```

## Running application
```bash
docker-compose -f misc/docker/docker-compose.yml up -d

./mvnw spring-boot:run -Dspring-boot.run.profiles=development  # or via ide

```

## Running apllication via ide
- Run Application 
  - Edit Configurations:
    Add parameter in 'Environment variables:' 
      spring.profiles.active=development
  
    ![Alt text](docs/application_environment.png?raw=true "Edit Configuration / Environment variables")

## Removing apllication and reset data on Mongo
```bash
docker-compose -f misc/docker/docker-compose.yml down -v
```

- Mongo Express ([mongo-express](http://localhost:8086 "mongo-express"))
  - user: 'dev', pwd: 'dev!'
  - Note: To access Mongo, it's not necessary run the application, just the Docker.

- Swagger-ui ([swagger](http://localhost:8080/swagger-ui/#/ "swagger"))
- API docs ([api-docs](http://localhost:8080/v3/api-docs "api-docs"))
- Actuator ([Actuator](http://localhost:8080/actuator "Actuator"))
- Health ([Health](http://localhost:8080/actuator/health "Health"))
- Application Info(git+build) ([Info](http://localhost:8080/actuator/info "Info"))
- Application Environment variable ([Env](http://localhost:8080/actuator/env "Env"))

## Building application

```
docker build --file Dockerfile -t opin-srv-app .

docker run -p 8080:8080 opin-srv-app
```

- Running sonar analysis local
  `./mvnw sonar:sonar`

- Run PMD Linter rules with CPD(Copy Paste Detection)
  `./mvnw pmd:pmd pmd:cpd`
 
## Running sonarqube

- The SonarQube container is created when docker-compose is run

``` docker-compose -f misc/docker/docker-compose.yml up -d ```

- To run the sonarqube it needs the token, it can be found on localhost:9090, at the profile -> My account -> Security and generate token

```
mvn --batch-mode verify sonar:sonar -Dsonar.host.url=http://localhost:9000 -Dsonar.login="admin" -Dsonar.password="dev!"
```

## Running sonarqube with Mutation Coverage

```
mvn clean --batch-mode verify org.pitest:pitest-maven:mutationCoverage  sonar:sonar -Dsonar.host.url=http://localhost:9000 -Dsonar.login="admin" -Dsonar.password="dev!"
```

- Run sonarqube with minimum coverage

```
mvn clean --batch-mode verify org.pitest:pitest-maven:mutationCoverage sonar:sonar -Dsonar.host.url=http://localhost:9000 -Dsonar.login="admin" -Dsonar.password="dev!" 
-DmutationThreshold=90
```

## Running stress tests
"In order to run the stress test, all Docker containers must be up and running ([Running application](#running-application)).

Two separate scripts have been created for this purpose, 'docker_run.sh' and 'client_test.sh'.

- **docker_run.sh**: Creates a new image of the current application, with memory and CPU limitations based on the provided parameters, enabling the determination of the best application configuration.

- **client_test.sh**: Executes multiple concurrent calls to the application endpoint, putting it under maximum stress.

### Docker run script
Arguments
- -m
  * The maximum memory allocation for the POD and JVM.
  * Default: 512m
- -r
  * The starting memory capacity (reserved memory) for the POD and JVM.
  * Default: 256m
- -b
  * This flag determines whether to build the image during script execution. If you wish to modify any of the other parameters (e.g. memory), this option must be set to TRUE.
  * Default: true
- -c
  * Limits the amount of CPU allocated to the POD, with the maximum amount not exceeding the number of cores on the host machine.
  * Default: no limit

Usage:
```bash
. misc/docker/docker_run.sh -b true -r 256m -m 512m -c 4
```

### Client tests script
Once the 'docker_run.sh' script has been executed, the container will be up and running, ready for use. At this point, the 'client_test.sh' script can be modified to perform calls to the target address. Please note that the script is just an example and you are free to customize and adapt it to your specific application needs.

Usage:
```bash
. misc/docker/client_test.sh
```

## Troubleshooting

- Install docker

```bash
sudo apt-get update -y
 
sudo apt-get purge docker-ce docker-ce-cli containerd.io -y
 
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo apt-get install docker-compose
```

- Docker permission denied

```bash
sudo usermod -aG docker $(whoami)
sudo chmod 777 /var/run/docker.sock
docker ps

  ```

- With Redis UP, to access redis-cli inside container run the following command:

```sh
docker exec -it <nome_container> redis-cli
```

- Redis-cli: To monitor calls:

```sh
monitor
```

- Redis-cli: To list all keys stored:

```sh
keys *
```

- Redis-cli: To get a key value:

```sh
GET "key"
```

- Redis-cli: To see the time-to-live of a key:

```sh
TTL "key"
```

- Redis-cli: To clear all keys

```sh
FLUSHALL
```
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																										   