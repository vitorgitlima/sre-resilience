server:
  compression:
    enabled: true
    mime-types: text/javascript,application/javascript,application/json
    min-response-size: 1024
  port: ${SERVER_PORT:8080}
  servlet.context-path: ${APPLICATION_CONTEXT:}

application:
  timeZone: GMT-3
  rest:
    config:
      timeout: 60000
      connectTimeout: 60000

spring:
  messages:
    encoding: ISO-8859-1
  jmx:
    enabled: false
  main:
    banner-mode: "off"
    lazy-initialization: false
  application:
    name: Open Insurance - Fornecimento de Produtos Residenciais
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:production}
  cache:
    redis:
      time-to-live: ${CACHE_DEFAULT_TTL:30}
    type: redis
    enabled: ${CACHE_ENABLED:true}
  data:
    web:
      pageable:
        one-indexed-parameters: true
        page-parameter: page
        size-parameter: page-size
  redis:
    host: ${REDIS_HOST:localhost}
    password: ${REDIS_PASSWORD:}
    port: ${REDIS_PORT:6379}
    ssl: ${REDIS_SSL:false}
    connect-timeout: 1800000
    timeout: 3000
    client-type: JEDIS
    jedis.pool:
      max-idle: 20
      min-idle: 8
      max-active: 20

mongo-properties:
  url: ${MONGODB_URL:mongodb://${mongo-properties.username}:${mongo-properties.password}@${mongo-properties.host}:${mongo-properties.port}/${mongo-properties.database}?${mongo-properties.query-string}}
  host: ${MONGO_HOST:localhost}
  port: ${MONGO_PORT:27017}
  database: ${MONGO_DB:opin-db-apis}
  username: ${MONGO_USER:admin}
  password: ${MONGO_PASS:admin!}
  query-string: ${MONGO_QUERY_STRING:retryWrites=true&w=majority}
  connection-pool-max-connection-life-time: 3
  connection-pool-min-size: ${MONGO_MIN_CONNECTIONS:75}
  connection-pool-max-size: ${MONGO_MAX_CONNECTIONS:150}
  connection-pool-maintenance-frequency: 1
  connection-pool-maintenance-initial-delay: 5
  connection-pool-max-connection-idle-time: 1
  connection-pool-max-wait-time: 15
logging.level.org.mongodb.driver: ERROR

management:
  info:
    env:
      enabled: true
  endpoints:
    web:
      exposure:
        include: info, health
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true

info:
  application:
    name: ${spring.application.name}
    version: '@project.version@'
    swaggerVersion: 1.1.0

jetty:
  threads:
    min: 50
    max: 300
    idle-timeout: 15000

sre.resilience.retry.throw-sre-max-retries-exceed: true

# Definições de Retry
resilience4j.retry:
  configs:
    default:
      maxAttempts: 3 # Máximo de tentativas de retry que serão feitas
      waitDuration: 3s # Tempo de espera entre as tentativas de retry
      failAfterMaxAttempts: true # Booleano para indicar se a exceção "MaxRetriesExceededException" será lançada ao atingir o valor definido em "maxAttempts"
      retryExceptions: # Lista de exceções que, caso lançadas, será realizado o comportamento de retry
        - br.com.bradescoseguros.opin.businessrule.exception.RetriableBaseException
      ignoreExceptions: # Lista de exceções que, caso lançadas, não será realizado o comportamento de retry
        - io.github.resilience4j.circuitbreaker.CallNotPermittedException
  instances: # Define as instancias de retrys que teremos em nossa aplicação. Novas instancias podem ser criadas conforme necessário
    cosmoRetry:
      baseConfig: default # Essa configuração indica que estamos herdando todas as configurações default. As definições seguintes sobrescrevem a configuração default e podem ser alteradas conforme necessário
      maxAttempts: 10
      waitDuration: 2s
      retryExceptions:
        - br.com.bradescoseguros.opin.businessrule.exception.RetriableBaseException
        - org.springframework.dao.DataAccessResourceFailureException
        - com.mongodb.MongoSocketOpenException
        - java.net.ConnectException
    apiRetry:
      baseConfig: default
      waitDuration: 5s
      retryExceptions:
        - br.com.bradescoseguros.opin.businessrule.exception.RetriableBaseException
        - org.springframework.web.client.HttpServerErrorException
    apiBulkhead:
      baseConfig: default
      maxAttempts: 2
      waitDuration: 5s
      retryExceptions:
        - io.github.resilience4j.bulkhead.BulkheadFullException
    apiTimeLimiter:
      baseConfig: default
      waitDuration: 5s
      retryExceptions:
        - br.com.bradescoseguros.opin.interfaceadapter.exception.TimeOutException



# Definições de CircuitBreaker
resilience4j.circuitbreaker:
  configs:
    default:
      registerHealthIndicator: true
      failure-rate-threshold: 50 # Threshold de falhas para ir para estado de "Aberto", em porcentagem.
      minimum-number-of-calls: 5  # Número de chamadas mínimas que são necessárias antes do CircuitBreaker poder calcular o error-rate. Se o número for 10, então ao menos 10 requisições tem que ser armazenadas para que seja calculado o valor da taxa de erro
      automatic-transition-from-open-to-half-open-enabled: true # Dispara um thread que faz a transição quando o tempo terminar. Caso seja false, aguarda uma nova request para mudar de status
      wait-duration-in-open-state: 50s # Tempo de espera no estado "Aberto". Será movido para o estado de "Semi-Aberto" após esse tempo
      permitted-number-of-calls-in-half-open-state: 3 # Número máximo de requisições permitidas quando no estado "Semi-Aberto". As demais requisições serão rejeitadas com CallNotPermittedException, até que todas as chamadas permitidas sejam concluídas.
      sliding-window-size: 10 # Tamanho da janela que é usada para registrar o resultado das chamadas quando o circuito esta fechado (quantas chamadas ele memoriza). Esse valor precisa ser maior que os valores de análise. Caso seja menor, vai sobrescrever o valor de requisições minimas necessárias
      sliding-window-type: count_based # COUNT_BASED ou TIME_BASED. Se for TIME, os segundos das ultimas requisições serão armazenados para cálculos
  instances: # Define as instancias de circuitBreakers que teremos em nossa aplicação. Novas instancias podem ser criadas conforme necessário
    cosmoCircuitBreaker:
      baseConfig: default # Essa configuração indica que estamos herdando todas as configurações default. As definições seguintes sobrescrevem a configuração default e podem ser alteradas conforme necessário
      failure-rate-threshold: 90
      minimum-number-of-calls: 15
      sliding-window-size: 20
    apiCircuitBreaker:
      baseConfig: default
      automatic-transition-from-open-to-half-open-enabled: false
      recordExceptions:
        - org.springframework.web.client.HttpServerErrorException

resilience4j.bulkhead:
  instances:
    semaphoreBulkhead:
      maxConcurrentCalls: 2
      maxWaitDuration: 1s

resilience4j.thread-pool-bulkhead:
  configs:
    default:
        maxThreadPoolSize: 2 # Valor máximo do pool de threads
        coreThreadPoolSize: 1 # O valor "core" do pool de threads
        queueCapacity: 2 # Capacidade da fila de requisições que irão aguardar
        keepAliveDuration: 20 # Quando o número de Threads for maior que o "core", representa o tempo maximo que as threads ociosas em excesso irão aguardar por novas tarefas antes de serem encerradas
  instances: # Define as instancias de bulkheads que teremos em nossa aplicação. Novas instancias podem ser criadas conforme necessário
    bulkheadInstance:
      baseConfig: default # Essa configuração indica que estamos herdando todas as configurações default. As definições seguintes sobrescrevem a configuração default e podem ser alteradas conforme necessário


# Definições de Time Limiter
resilience4j.timelimiter:
  configs:
    default:
      timeoutDuration: 10s # Duração limite da execução antes de lançar uma exceção
      cancelRunningFuture: true # Indica que o cancelar deve ser invocado quando estiver executando um Future
  instances:
    limiterApi:
      baseConfig: default
    limiterDb:
      baseConfig: default
